from datetime import datetime, timedeltafrom befree.api_model.orders.public import OrdersPublicfrom befree.api_model.orders.db_queries.queries import QueriesOrdersimport allureimport timefrom mimesis import Personclass Utils(OrdersPublic, QueriesOrders):    def get_address(self, city_fias_id="c2deb16a-0330-4f05-821f-1d09c93331e6", street="ул 10-я Красноармейская",                    building="22"):        streets = self.api_geo.suggestion_street(city_fias_id=city_fias_id, query=street)        buildings = self.api_geo.suggestion_building(street_fias_id=streets.json()["data"][0]["fiasId"],                                                     query=building)        address = {            "intervals": {                "fiasId": buildings.json()["data"][0]["fiasId"],                "street": streets.json()["data"][0]["name"],                "building": buildings.json()["data"][0]["building"],                "zipcode": buildings.json()["data"][0]["zipcode"]            },            "shipping": {                "streetName": streets.json()["data"][0]["name"],                "streetFiasId": streets.json()["data"][0]["fiasId"],                "building": buildings.json()["data"][0]["building"],                "buildingFiasId": buildings.json()["data"][0]["fiasId"],                "zipcode": buildings.json()["data"][0]["zipcode"]            },        }        return address    def generate_customer_data(self):        person = Person("en")        customer = dict()        customer["email"] = person.email()        customer["first_name"] = person.first_name()        customer["last_name"] = person.last_name()        return customer    def create_default_order(self, items, **kwargs):        """ create order with shipping = pickup and payment = cash """        token = kwargs.pop("token") if "token" in kwargs else ""        promocode = kwargs.pop("promocode") if "promocode" in kwargs else ""        with allure.step("Создаем корзину"):            cart = self.api_cart.create(items=items, token=token)            assert cart.status_code == 200            cart_uuid = cart.json()["data"]["cartUuid"]        with allure.step("Если передан промокод, то добавляем его в корзине"):            if promocode:                cart_with_promocode = self.api_cart.update_promocode(cart_uuid=cart_uuid, promocode=promocode)                assert cart_with_promocode.json()["data"]["cartUuid"]        with allure.step("Ищем доступный ПВЗ"):            pickuppoints = self.api_delivery.get_pickpoints(cart_uuid=cart_uuid, methods=["pickup"])            assert pickuppoints.status_code == 200        with allure.step("Обновляем корзину с доставкой в ПВЗ"):            cart_with_shipping = self.api_cart.update_pickup(cart_uuid=cart_uuid,                                                             pickpoint_id=pickuppoints.json()["data"][0]["id"],                                                             token=token)            assert cart_with_shipping.json()["data"]["cartUuid"]        with allure.step("Устанавливаем кастомера в корзине"):            customer = self.generate_customer_data()            cart_with_customer = self.api_cart.set_customer(cart_uuid=cart_uuid, customer=customer, token=token)            assert cart_with_customer.json()["data"]["cartUuid"]        with allure.step("Обновляем корзину с методом оплаты cash"):            cart_with_payment = self.api_cart.update_payment(cart_uuid=cart_uuid, method="cash", token=token)            time.sleep(5)            assert cart_with_payment.json()["data"]["cartUuid"]        with allure.step("Оформляем заказ"):            order = self.api_order.send_order(cart_uuid=cart_with_payment.json()["data"]["cartUuid"])            assert order.status_code == 200            assert order.json()["data"]["paymentMethods"]    def get_pricerule_by_status(self, status: str):        now_datetime = datetime.today().strftime("%Y-%m-%d %H:%M:%S")        if status == "pending":            conditions = [f"and pr.start_at > '{now_datetime}'"]        if status == "running":            conditions = [                f"and (start_at <= '{now_datetime}' or start_at is null) " f"and ('{now_datetime}' <= end_at  or end_at is null)"]        if status == "ended":            conditions = [f"and '{now_datetime}' > end_at"]        pricerule_id = self.get_pricerule(conditions=conditions)        return pricerule_id    def time_subtraction(self, date_str, time_delta=15):        date_format = "%Y-%m-%d %H:%M:%S"        original_datetime = datetime.strptime(date_str, date_format)        new_datetime = original_datetime - timedelta(minutes=time_delta)        return new_datetime.strftime("%Y-%m-%d %H:%M:%S")    def softdelete_pricerules(self, condition):        running_pricerules = [            "and (pr.start_at <= NOW() or pr.start_at is null) and (NOW() <= pr.end_at  or pr.end_at is null)"]        conditions = running_pricerules + condition        pricerules_db = self.get_pricerules_by_conditions(conditions=conditions)        if len(pricerules_db) > 0:            pricerules = ', '.join(str(item['id']) for item in pricerules_db)            self.delete_pricerules(pricerules=pricerules)